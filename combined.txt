lib/core/adapters.dart
lib/core/cached_object.dart
lib/core/encoded_adapters.dart
lib/core/extensions.dart
lib/core/base_object.dart
lib/core/prf_service.dart
lib/core/adapter_map.dart
lib/prfy_types/prfy.dart
lib/prfy_types/prfy_json.dart
lib/prfy_types/prfy_enum.dart
lib/prf_types/prf_enum.dart
lib/prf_types/prf_json.dart
lib/prf_types/prf.dart
lib/services/prf_cooldown.dart
lib/services/prf_rate_limiter.dart
lib/prf.dart
import 'package:shared_preferences/shared_preferences.dart';

abstract class PrfAdapter<T> {
  /// Function to retrieve the value from SharedPreferences.
  Future<T?> getter(SharedPreferencesAsync prefs, String key);

  /// Function to save the value to SharedPreferences.
  Future<void> setter(SharedPreferencesAsync prefs, String key, T value);

  const PrfAdapter();
}

/// Bool adapter implementation
class BoolAdapter extends PrfAdapter<bool> {
  @override
  Future<bool?> getter(SharedPreferencesAsync prefs, String key) async {
    return await prefs.getBool(key);
  }

  @override
  Future<void> setter(
      SharedPreferencesAsync prefs, String key, bool value) async {
    await prefs.setBool(key, value);
  }

  const BoolAdapter();
}

/// Int adapter implementation
class IntAdapter extends PrfAdapter<int> {
  @override
  Future<int?> getter(SharedPreferencesAsync prefs, String key) async {
    return await prefs.getInt(key);
  }

  @override
  Future<void> setter(
      SharedPreferencesAsync prefs, String key, int value) async {
    await prefs.setInt(key, value);
  }

  const IntAdapter();
}

/// Double adapter implementation
class DoubleAdapter extends PrfAdapter<double> {
  @override
  Future<double?> getter(SharedPreferencesAsync prefs, String key) async {
    return await prefs.getDouble(key);
  }

  @override
  Future<void> setter(
      SharedPreferencesAsync prefs, String key, double value) async {
    await prefs.setDouble(key, value);
  }

  const DoubleAdapter();
}

/// String adapter implementation
class StringAdapter extends PrfAdapter<String> {
  @override
  Future<String?> getter(SharedPreferencesAsync prefs, String key) async {
    return await prefs.getString(key);
  }

  @override
  Future<void> setter(
      SharedPreferencesAsync prefs, String key, String value) async {
    await prefs.setString(key, value);
  }

  const StringAdapter();
}

/// StringList adapter implementation
class StringListAdapter extends PrfAdapter<List<String>> {
  @override
  Future<List<String>?> getter(SharedPreferencesAsync prefs, String key) async {
    return await prefs.getStringList(key);
  }

  @override
  Future<void> setter(
      SharedPreferencesAsync prefs, String key, List<String> value) async {
    await prefs.setStringList(key, value);
  }

  const StringListAdapter();
}
import 'package:prf/prf.dart';
import 'package:shared_preferences/shared_preferences.dart';

/// Base class for all prf persistence variables.
///
/// Handles the core functionality for storing, retrieving, and caching values
/// of type [T] in SharedPreferences. This serves as the foundation for all
/// type-specific prf implementations.
abstract class CachedPrfObject<T> extends BasePrfObject<T> {
  /// Cached value to avoid repeated disk reads.
  T? _cachedValue;

  /// Creates a new [Prf] with the specified [key], getter, setter, and optional [defaultValue].
  ///
  /// The [key] must be unique within your application's SharedPreferences storage.
  /// The [_getter] and [_setter] functions handle the actual reading and writing to storage.
  CachedPrfObject(super.key, {super.defaultValue});

  /// Retrieves the current value from cache or SharedPreferences.
  ///
  /// If the value is cached, returns the cached value.
  /// If not cached but exists in SharedPreferences, retrieves, caches, and returns it.
  /// If not found and [defaultValue] is set, stores the default value and returns it.
  /// Returns null if no value is found and no default is set.
  @override
  Future<T?> getValue(SharedPreferencesAsync prefs) async {
    if (_cachedValue != null) return _cachedValue;
    return _cachedValue ??= await super.getValue(prefs);
  }

  /// Saves a new value to SharedPreferences and updates the cache.
  ///
  /// Updates the cache only if the save operation succeeds.
  /// Returns a [Future<bool>] indicating whether the operation was successful.
  @override
  Future<void> setValue(SharedPreferencesAsync prefs, T value) async {
    await super.setValue(prefs, value);
    _cachedValue = value;
  }

  /// Removes the value from both the cache and SharedPreferences.
  ///
  /// Clears the cached value and removes the key from SharedPreferences.
  @override
  Future<void> removeValue(SharedPreferencesAsync prefs) async {
    await super.removeValue(prefs);
    _cachedValue = null;
  }
}
import 'dart:convert';
import 'dart:typed_data';

import 'package:prf/prf.dart';
import 'package:shared_preferences/shared_preferences.dart';

abstract class PrfEncodedAdapter<T, TStore> extends PrfAdapter<T> {
  final PrfAdapter<TStore> _storingAdapter =
      PrfAdapterMap.instance.of<TStore>();

  @override
  Future<T?> getter(SharedPreferencesAsync prefs, String key) async {
    final getRaw = await _storingAdapter.getter(prefs, key);
    return decode(getRaw);
  }

  @override
  Future<void> setter(SharedPreferencesAsync prefs, String key, T value) async {
    final encoded = encode(value);
    await _storingAdapter.setter(prefs, key, encoded);
  }

  TStore encode(T value);

  T? decode(TStore? stored);

  PrfEncodedAdapter();
}

class EnumAdapter<T extends Enum> extends PrfEncodedAdapter<T, int> {
  final List<T> values;

  EnumAdapter(this.values);

  @override
  T? decode(int? index) {
    if (index == null || index < 0 || index >= values.length) {
      return null;
    }
    return values[index];
  }

  @override
  int encode(T value) => value.index;
}

/// JSON adapter implementation that requires fromJson and toJson converters
class JsonAdapter<T> extends PrfEncodedAdapter<T, String> {
  final T Function(Map<String, dynamic> json) fromJson;
  final Map<String, dynamic> Function(T object) toJson;

  JsonAdapter({required this.fromJson, required this.toJson});

  @override
  T? decode(String? jsonString) {
    if (jsonString == null) return null;
    try {
      final map = jsonDecode(jsonString);
      if (map is Map<String, dynamic>) {
        return fromJson(map);
      }
      return null;
    } catch (_) {
      return null;
    }
  }

  @override
  String encode(T value) => jsonEncode(toJson(value));
}

class DateTimeAdapter extends PrfEncodedAdapter<DateTime, String> {
  DateTimeAdapter();

  @override
  DateTime? decode(String? base64) {
    if (base64 == null) return null;
    try {
      final bytes = base64Decode(base64);
      if (bytes.length < 8) return null; // Too short to contain a timestamp
      final micros = ByteData.sublistView(bytes).getInt64(0, Endian.big);
      return DateTime.fromMicrosecondsSinceEpoch(micros);
    } catch (_) {
      return null;
    }
  }

  @override
  String encode(DateTime dateTime) {
    final buffer = ByteData(8);
    buffer.setInt64(0, dateTime.microsecondsSinceEpoch, Endian.big);
    return base64Encode(buffer.buffer.asUint8List());
  }
}

/// Duration adapter implementation
class DurationAdapter extends PrfEncodedAdapter<Duration, int> {
  DurationAdapter();

  @override
  Duration? decode(int? stored) {
    if (stored == null) return null;
    return Duration(microseconds: stored);
  }

  @override
  int encode(Duration value) => value.inMicroseconds;
}

/// BigInt adapter implementation
class BigIntAdapter extends PrfEncodedAdapter<BigInt, String> {
  BigIntAdapter();

  @override
  BigInt? decode(String? base64) {
    if (base64 == null) return null;
    try {
      final bytes = base64Decode(base64);
      if (bytes.isEmpty) return BigInt.zero;

      // First byte indicates sign (0 for positive, 1 for negative)
      final isNegative = bytes[0] == 1;

      // Remaining bytes are the magnitude
      var result = BigInt.zero;
      for (var i = 1; i < bytes.length; i++) {
        result = (result << 8) | BigInt.from(bytes[i]);
      }

      return isNegative ? -result : result;
    } catch (_) {
      return null; // Invalid format
    }
  }

  @override
  String encode(BigInt bigInt) {
    // Convert to efficient binary representation
    final isNegative = bigInt.isNegative;
    final magnitude = bigInt.abs();

    // Calculate how many bytes we need
    var tempMag = magnitude;
    var byteCount = 0;
    do {
      byteCount++;
      tempMag = tempMag >> 8;
    } while (tempMag > BigInt.zero);

    // Create a byte array with an extra byte for the sign
    final bytes = Uint8List(byteCount + 1);

    // First byte indicates sign (0 for positive, 1 for negative)
    bytes[0] = isNegative ? 1 : 0;

    // Fill in the magnitude bytes in big-endian order
    var tempValue = magnitude;
    for (var i = byteCount; i > 0; i--) {
      bytes[i] = (tempValue & BigInt.from(0xFF)).toInt();
      tempValue = tempValue >> 8;
    }

    return base64Encode(bytes);
  }
}

/// Bytes (Uint8List) adapter implementation
class BytesAdapter extends PrfEncodedAdapter<Uint8List, String> {
  BytesAdapter();

  @override
  Uint8List? decode(String? base64) {
    if (base64 == null) return null;
    try {
      return base64Decode(base64);
    } catch (_) {
      return null; // corrupted or invalid base64
    }
  }

  @override
  String encode(Uint8List value) => base64Encode(value);
}
import 'package:prf/prf.dart';

extension PrfOperationExtensions<T> on BasePrfObject<T> {
  Future<T?> get() async {
    return await getValue(PrfService.instance);
  }

  Future<void> set(T value) async {
    await setValue(PrfService.instance, value);
  }

  Future<void> remove() async {
    await removeValue(PrfService.instance);
  }

  Future<bool> isNull() async {
    return await isValueNull(PrfService.instance);
  }

  Future<T> getOrFallback(T fallback) async {
    return (await get()) ?? fallback;
  }

  Future<bool> existsOnPrefs() async {
    return await PrfService.instance.containsKey(key);
  }
}
import 'package:prf/prf.dart';
import 'package:shared_preferences/shared_preferences.dart';

abstract class BasePrfObject<T> {
  final String key;

  PrfAdapter<T> get adapter;

  final T? defaultValue;

  const BasePrfObject(this.key, {this.defaultValue});

  Future<bool> _exists(SharedPreferencesAsync prefs) async {
    return await prefs.containsKey(key);
  }

  Future<T?> getValue(SharedPreferencesAsync prefs) async {
    final exists = await _exists(prefs);
    if (!exists && defaultValue != null) {
      await setValue(prefs, defaultValue as T);
      return defaultValue;
    }
    return await adapter.getter(prefs, key);
  }

  Future<bool> isValueNull(SharedPreferencesAsync prefs) async {
    return await getValue(prefs) == null;
  }

  Future<void> setValue(SharedPreferencesAsync prefs, T value) async {
    await adapter.setter(prefs, key, value);
  }

  Future<void> removeValue(SharedPreferencesAsync prefs) async {
    await prefs.remove(key);
  }
}
import 'package:shared_preferences/shared_preferences.dart';
import 'package:shared_preferences/util/legacy_to_async_migration_util.dart';

abstract class PrfService {
  static SharedPreferencesAsync? _overriddenPrefs;

  PrfService._();

  static SharedPreferencesAsync get instance =>
      _overriddenPrefs ??= SharedPreferencesAsync();

  static void overrideWith(SharedPreferencesAsync prefs) {
    _overriddenPrefs = prefs;
  }

  static void resetOverride() {
    _overriddenPrefs = null;
  }

  static Future<void> migrateFromLegacyPrefsIfNeeded({
    String migrationKey = 'prf_migrated',
  }) async {
    final legacy = await SharedPreferences.getInstance();
    const sharedPreferencesOptions = SharedPreferencesOptions(); // defaults

    await migrateLegacySharedPreferencesToSharedPreferencesAsyncIfNecessary(
      legacySharedPreferencesInstance: legacy,
      sharedPreferencesAsyncOptions: sharedPreferencesOptions,
      migrationCompletedKey: 'migrationCompleted',
    );
  }

  // --- DEPRECATED METHODS BELOW ---

  /// Clears all `SharedPreferences` values.
  /// Optionally pass an [allowList] to retain specific keys.
  @Deprecated('Use instance.clear() instead')
  static Future<void> clear({Set<String>? allowList}) async {
    throw UnsupportedError(
        'This method is deprecated. Use Prf.instance.clear() instead.');
  }

  @Deprecated('Use Prf.instance instead')
  static SharedPreferences? _deprecatedPrefs;

  @Deprecated('Use Prf.instance instead')
  static Future<SharedPreferences>? _initFuture;

  @Deprecated('Use Prf.instance instead')
  static Future<SharedPreferences> _init() {
    _initFuture ??= SharedPreferences.getInstance().then((prefs) {
      _deprecatedPrefs = prefs;
      return prefs;
    });
    return _initFuture!;
  }

  @Deprecated('Use Prf.instance instead')
  static Future<SharedPreferences> getInstance() async {
    return _deprecatedPrefs ?? await _init();
  }

  @Deprecated('No longer needed with SharedPreferencesAsync')
  static void reset() {
    _deprecatedPrefs = null;
    _initFuture = null;
  }

  @Deprecated('Use Prf.instance instead')
  static SharedPreferences? get maybePrefs => _deprecatedPrefs;

  @Deprecated('No longer needed with SharedPreferencesAsync')
  static bool get isInitialized => _deprecatedPrefs != null;
}
import 'dart:typed_data';
import 'package:prf/core/encoded_adapters.dart';
import 'package:prf/core/adapters.dart';

/// Registry for PrfAdapter instances
class PrfAdapterMap {
  final Map<Type, PrfAdapter<dynamic>> _registry = {};

  /// Returns true if any adapters have been registered
  bool registered = false;

  /// Creates a new adapter registry
  PrfAdapterMap();

  /// Singleton instance of the adapter registry
  static PrfAdapterMap instance = PrfAdapterMap();

  /// Registers an adapter for type [T] if not already registered.
  /// Set [override] to true to replace an existing adapter.
  void register<T>(
    PrfAdapter<T> adapter, {
    bool override = false,
  }) {
    if (override || !_registry.containsKey(T)) {
      _registry[T] = adapter;
    }
  }

  /// Retrieves the adapter for type [T].
  /// Registers all adapters if none have been registered yet.
  /// For enum types, tries to use a pre-registered enum adapter.
  /// Throws if no adapter is registered for type [T].
  /// Retrieves the adapter for type [T]. Throws if not registered.
  PrfAdapter<T> of<T>() {
    if (!registered) {
      registerAll();
    }
    final adapter = _registry[T];
    if (adapter == null) {
      throw StateError('No adapter registered for type $T');
    }
    return adapter as PrfAdapter<T>;
  }

  /// Returns true if an adapter for type [T] has been registered.
  bool contains<T>() => _registry.containsKey(T);

  /// Registers all adapters if none have been registered yet.
  void registerAll() {
    if (registered) return;
    registered = true;
    registerAdapters();
  }

  /// Registers all standard adapters
  void registerAdapters() {
    // Register primitive types
    register<bool>(const BoolAdapter());
    register<int>(const IntAdapter());
    register<double>(const DoubleAdapter());
    register<String>(const StringAdapter());
    register<List<String>>(const StringListAdapter());

    // Register special types
    register<DateTime>(DateTimeAdapter());
    register<Duration>(DurationAdapter());
    register<BigInt>(BigIntAdapter());
    register<Uint8List>(BytesAdapter());
  }
}
import 'package:prf/prf.dart';

class Prfy<T> extends BasePrfObject<T> {
  Prfy(super.key, {super.defaultValue});

  @override
  final PrfAdapter<T> adapter = PrfAdapterMap.instance.of<T>();
}
import 'package:prf/prf.dart';

class PrfyJson<T> extends BasePrfObject<T> {
  final PrfAdapter<T> _adapter;

  @override
  PrfAdapter<T> get adapter => _adapter;

  PrfyJson(
    super.key, {
    required T Function(Map<String, dynamic> json) fromJson,
    required Map<String, dynamic> Function(T object) toJson,
    super.defaultValue,
  }) : _adapter = JsonAdapter(fromJson: fromJson, toJson: toJson);
}
import 'package:prf/prf.dart';

class PrfyEnum<T extends Enum> extends BasePrfObject<T> {
  final EnumAdapter<T> _adapter;

  @override
  EnumAdapter<T> get adapter => _adapter;

  PrfyEnum(super.key, {required List<T> values, super.defaultValue})
      : _adapter = EnumAdapter<T>(values);
}
import 'package:prf/prf.dart';

class PrfEnum<T extends Enum> extends CachedPrfObject<T> {
  final EnumAdapter<T> _adapter;

  @override
  EnumAdapter<T> get adapter => _adapter;

  PrfEnum(super.key, {required List<T> values, super.defaultValue})
      : _adapter = EnumAdapter<T>(values);
}
import 'package:prf/prf.dart';

class PrfJson<T> extends CachedPrfObject<T> {
  final PrfAdapter<T> _adapter;

  @override
  PrfAdapter<T> get adapter => _adapter;

  PrfJson(
    super.key, {
    required T Function(Map<String, dynamic> json) fromJson,
    required Map<String, dynamic> Function(T object) toJson,
    super.defaultValue,
  }) : _adapter = JsonAdapter(fromJson: fromJson, toJson: toJson);
}
import 'package:prf/prf.dart';

class Prf<T> extends CachedPrfObject<T> {
  Prf(super.key, {super.defaultValue});

  @override
  PrfAdapter<T> get adapter => PrfAdapterMap.instance.of<T>();
}
import 'package:prf/prf.dart';

/// A utility for managing cooldown logic using persisted DateTime and Activation Count.
///
/// Stores:
/// - the last activation time (`<prefix>_cd_date_time`)
/// - the total activation count (`<prefix>_cd_count`)
///
/// Example:
/// ```dart
/// final cooldown = PrfCooldown('daily_reward', duration: Duration(hours: 24));
/// if (!await cooldown.isCooldownActive()) {
///   await cooldown.activateCooldown();
/// }
/// ```
class PrfCooldown {
  final Prfy<DateTime> _lastActivated;
  final Prfy<int> _activationCount;

  /// The cooldown duration.
  final Duration duration;

  /// Creates a new cooldown with the specified prefix and duration.
  ///
  /// - The [prefix] is used to create unique keys for storing cooldown data.
  /// - The [duration] specifies how long the cooldown should last.
  PrfCooldown(String prefix, {required this.duration})
      : _lastActivated = Prfy<DateTime>('prf_${prefix}_cd_date_time'),
        _activationCount = Prfy<int>('prf_${prefix}_cd_count', defaultValue: 0);

  /// Returns true if the cooldown is still active.
  ///
  /// A cooldown is active if it has been activated and the specified
  /// duration has not yet elapsed.
  Future<bool> isCooldownActive() async {
    final last = await _lastActivated.get();
    if (last == null) return false;
    return DateTime.now().isBefore(last.add(duration));
  }

  /// Returns true if the cooldown has expired or was never activated.
  ///
  /// This is the inverse of [isCooldownActive].
  Future<bool> isExpired() async => !(await isCooldownActive());

  /// Activates the cooldown using the default duration.
  ///
  /// Sets the activation time to the current time and increments
  /// the activation count.
  Future<void> activateCooldown() async {
    await _lastActivated.set(DateTime.now());
    final count = await _activationCount.getOrFallback(0);
    await _activationCount.set(count + 1);
  }

  /// Attempts to activate the cooldown only if it is not currently active.
  ///
  /// Returns `true` if the cooldown was activated (meaning it was not active before).
  /// Returns `false` if the cooldown was already active and no action was taken.
  ///
  /// This is a convenience method that combines checking and activating in one call.
  Future<bool> tryActivate() async {
    if (await isExpired()) {
      await activateCooldown();
      return true;
    }
    return false;
  }

  /// Resets the cooldown by clearing the activation timestamp.
  ///
  /// This effectively ends the cooldown immediately, but preserves
  /// the activation count.
  Future<void> reset() async {
    await _lastActivated.remove();
  }

  /// Completely resets the cooldown and counter.
  ///
  /// Clears the activation timestamp and resets the activation count to zero.
  Future<void> completeReset() async {
    await reset();
    await _activationCount.set(0);
  }

  /// Gets the remaining time until the cooldown ends.
  ///
  /// Returns Duration.zero if the cooldown has expired or was never activated.
  Future<Duration> timeRemaining() async {
    final last = await _lastActivated.get();
    if (last == null) return Duration.zero;
    final end = last.add(duration);
    final now = DateTime.now();
    return end.isAfter(now) ? end.difference(now) : Duration.zero;
  }

  /// Returns the remaining cooldown time in seconds.
  ///
  /// Returns 0 if the cooldown has expired or was never activated.
  Future<int> secondsRemaining() async => (await timeRemaining()).inSeconds;

  /// Returns the percentage of cooldown time remaining as a value between 0.0 and 1.0.
  ///
  /// Returns 0.0 if the cooldown has expired or was never activated.
  /// Returns 1.0 if the cooldown was just activated.
  Future<double> percentRemaining() async {
    final remaining = await timeRemaining();
    final ratio = remaining.inMilliseconds / duration.inMilliseconds;
    return ratio.clamp(0.0, 1.0);
  }

  /// Returns the timestamp of the last activation, or null if never activated.
  Future<DateTime?> getLastActivationTime() async {
    return await _lastActivated.get();
  }

  /// Returns the timestamp when the cooldown will expire, or null if not active.
  Future<DateTime?> getEndTime() async {
    final last = await _lastActivated.get();
    return last?.add(duration);
  }

  /// Completes when the cooldown expires.
  ///
  /// If the cooldown is already expired or was never activated,
  /// this future completes immediately.
  Future<void> whenExpires() async {
    final remaining = await timeRemaining();
    if (remaining > Duration.zero) {
      await Future.delayed(remaining);
    }
  }

  /// Returns the number of times the cooldown has been activated.
  Future<int> getActivationCount() async {
    return await _activationCount.getOrFallback(0);
  }

  /// Removes all saved values and duration from persistent storage.
  ///
  /// This method is primarily intended for testing and debugging purposes.
  Future<void> removeAll() async {
    await _lastActivated.remove();
    await _activationCount.remove();
  }

  /// Checks if any values related to this cooldown exist in persistent storage.
  ///
  /// This method is primarily intended for testing and debugging purposes.
  /// Returns true if any of the cooldown values exist in storage.
  Future<bool> anyStateExists() async {
    bool lastActivated = await _lastActivated.existsOnPrefs();
    bool activationCount = await _activationCount.existsOnPrefs();
    return lastActivated || activationCount;
  }
}
import 'dart:math';
import 'package:prf/prf.dart';
import 'package:synchronized/synchronized.dart';

/// A robust, industry-grade token bucket rate limiter using `prf`.
///
/// Limits actions to a defined number within a given duration,
/// using a refillable token system with persistent storage.
///
/// Example:
/// ```dart
/// final limiter = PrfRateLimiter('chat_send', maxTokens: 100, refillDuration: Duration(minutes: 15));
/// final canSend = await limiter.tryConsume();
/// ```
class PrfRateLimiter {
  /// The maximum number of tokens that can be accumulated.
  final int maxTokens;

  /// The time period over which tokens are fully replenished.
  final Duration refillDuration;

  final Prfy<double> _tokenCount;
  final Prfy<DateTime> _lastRefill;
  final Lock _lock = Lock();

  /// Creates a new rate limiter with the specified prefix and configuration.
  ///
  /// - [prefix] is used to create unique keys for storing rate limiter data.
  /// - [maxTokens] defines the maximum number of operations allowed in the time period.
  /// - [refillDuration] specifies the time period over which tokens are fully replenished.
  PrfRateLimiter(
    prefix, {
    required this.maxTokens,
    required this.refillDuration,
  })  : _tokenCount = Prfy<double>('prf_${prefix}_rate_tokens',
            defaultValue: maxTokens.toDouble()),
        _lastRefill = Prfy<DateTime>('prf_${prefix}_rate_last_refill',
            defaultValue: DateTime.now());

  /// Returns `true` if the limiter is currently rate-limited (no token available).
  ///
  /// This is equivalent to checking if `getAvailableTokens() < 1`.
  Future<bool> isLimitedNow() async {
    final available = await getAvailableTokens();
    return available < 1;
  }

  /// Returns `true` if the limiter has at least one token available.
  ///
  /// This is the opposite of [isLimitedNow] and is provided as a convenience method.
  Future<bool> isReady() async {
    return !(await isLimitedNow());
  }

  /// Attempts to consume 1 token.
  ///
  /// Returns `true` if the action is allowed (token consumed), or `false` if rate limited.
  ///
  /// This method automatically handles token refill based on elapsed time since the last check.
  /// Attempts to consume 1 token atomically.
  Future<bool> tryConsume() => _lock.synchronized(() async {
        final now = DateTime.now();
        final tokens = await _tokenCount.getOrFallback(maxTokens.toDouble());
        final last = await _lastRefill.getOrFallback(now);

        final elapsedMs = now.difference(last).inMilliseconds;
        final refillRatePerMs = maxTokens / refillDuration.inMilliseconds;
        final refilledTokens = tokens + (elapsedMs * refillRatePerMs);
        final newTokenCount = min(maxTokens.toDouble(), refilledTokens);

        if (newTokenCount >= 1) {
          await _tokenCount.set(newTokenCount - 1);
          await _lastRefill.set(now);
          return true;
        } else {
          await _tokenCount.set(newTokenCount);
          await _lastRefill.set(now);
          return false;
        }
      });

  /// Executes the provided action if a token is available, otherwise returns null.
  ///
  /// This is a convenience method that combines [tryConsume] with executing an action.
  /// If a token is available, it will be consumed and the action will be executed.
  /// If no token is available, null will be returned without executing the action.
  ///
  /// Example:
  /// ```dart
  /// final result = await limiter.runIfAllowed(() async {
  ///   return await api.sendMessage(text);
  /// });
  /// // result will be null if rate limited
  /// ```
  Future<T?> runIfAllowed<T>(Future<T> Function() action) async {
    if (await tryConsume()) {
      return await action();
    }
    return null;
  }

  /// Gets the number of tokens currently available.
  ///
  /// This method calculates the current token count based on the stored value
  /// plus any tokens that would have been refilled since the last check.
  /// The returned value is capped at [maxTokens].
  Future<double> getAvailableTokens() async {
    final now = DateTime.now();
    final tokens = await _tokenCount.getOrFallback(maxTokens.toDouble());
    final last = await _lastRefill.getOrFallback(now);

    final elapsedMs = now.difference(last).inMilliseconds;
    final refillRatePerMs = maxTokens / refillDuration.inMilliseconds;
    final refilledTokens = tokens + (elapsedMs * refillRatePerMs);

    return min(maxTokens.toDouble(), refilledTokens);
  }

  /// Calculates the time remaining until the next token is available.
  ///
  /// Returns Duration.zero if a token is already available.
  /// This is useful for implementing retry mechanisms or displaying wait times to users.
  Future<Duration> timeUntilNextToken() async {
    final available = await getAvailableTokens();
    if (available >= 1) return Duration.zero;

    final refillRatePerMs = maxTokens / refillDuration.inMilliseconds;
    final needed = 1 - available;
    final msUntilNext = (needed / refillRatePerMs).ceil();
    return Duration(milliseconds: msUntilNext);
  }

  /// Fully resets the limiter to its initial state.
  ///
  /// This restores the token count to [maxTokens] and resets the refill timestamp
  /// to the current time. Useful for scenarios where you want to clear rate limits,
  /// such as after a user upgrade or payment.
  Future<void> reset() async {
    await _tokenCount.set(maxTokens.toDouble());
    await _lastRefill.set(DateTime.now());
  }

  /// Removes all persisted state from storage.
  ///
  /// This completely clears all rate limiter data from persistent storage.
  /// Primarily intended for testing and debugging purposes.
  Future<void> removeAll() async {
    await _tokenCount.remove();
    await _lastRefill.remove();
  }

  /// Checks if any rate limiter state exists in persistent storage.
  ///
  /// Returns true if either the token count or last refill timestamp
  /// exists in SharedPreferences. Useful for determining if this is
  /// the first time the rate limiter is being used.
  Future<bool> anyStateExists() async {
    return await _tokenCount.existsOnPrefs() ||
        await _lastRefill.existsOnPrefs();
  }

  /// Returns the `DateTime` when a token will be available.
  /// Returns `DateTime.now()` if already available.
  Future<DateTime> nextAllowedTime() async {
    final remaining = await timeUntilNextToken();
    return DateTime.now().add(remaining);
  }

  /// Returns detailed stats useful for debugging and logging.
  Future<PrfRateLimiterStats> debugStats() async {
    final now = DateTime.now();
    final tokens = await _tokenCount.getOrFallback(maxTokens.toDouble());
    final last = await _lastRefill.getOrFallback(now);
    final elapsedMs = now.difference(last).inMilliseconds;
    final refillRatePerMs = maxTokens / refillDuration.inMilliseconds;
    final refilledTokens = tokens + (elapsedMs * refillRatePerMs);
    final cappedTokenCount = min(maxTokens.toDouble(), refilledTokens);

    return PrfRateLimiterStats(
      tokens: tokens,
      lastRefill: last,
      maxTokens: maxTokens.toDouble(),
      refillDuration: refillDuration,
      now: now,
      refillRatePerMs: refillRatePerMs,
      refilledTokens: refilledTokens,
      cappedTokenCount: cappedTokenCount,
    );
  }
}

class PrfRateLimiterStats {
  final double tokens;
  final DateTime lastRefill;
  final double maxTokens;
  final Duration refillDuration;
  final DateTime now;
  final double refillRatePerMs;
  final double refilledTokens;
  final double cappedTokenCount;

  const PrfRateLimiterStats({
    required this.tokens,
    required this.lastRefill,
    required this.maxTokens,
    required this.refillDuration,
    required this.now,
    required this.refillRatePerMs,
    required this.refilledTokens,
    required this.cappedTokenCount,
  });

  @override
  String toString() {
    return '''
--- RateLimiterStats: ---
-------------------------
    tokens stored:       $tokens
    last refill:         $lastRefill
    now:                 $now
    elapsed ms:          ${now.difference(lastRefill).inMilliseconds}
    refill rate/ms:      $refillRatePerMs
    refilled tokens:     $refilledTokens
    capped token count:  $cappedTokenCount
    max tokens:          $maxTokens
    refill duration:     ${refillDuration.inMilliseconds} ms
''';
  }
}
library;

export 'core/adapter_map.dart';
export 'core/adapters.dart';
export 'core/base_object.dart';
export 'core/encoded_adapters.dart';
export 'core/extensions.dart';
export 'core/cached_object.dart';
export 'core/prf_service.dart';
export 'prf.dart';
export 'prf_types/legacy/prf_big_int.dart';
export 'prf_types/legacy/prf_bool.dart';
export 'prf_types/legacy/prf_bytes.dart';
export 'prf_types/legacy/prf_datetime.dart';
export 'prf_types/legacy/prf_double.dart';
export 'prf_types/legacy/prf_duration.dart';
export 'prf_types/legacy/prf_int.dart';
export 'prf_types/legacy/prf_string.dart';
export 'prf_types/legacy/prf_string_list.dart';
export 'prf_types/legacy/prf_theme_mode.dart';
export 'prf_types/prf.dart';
export 'prf_types/prf_enum.dart';
export 'prf_types/prf_json.dart';
export 'prfy_types/prfy.dart';
export 'prfy_types/prfy_enum.dart';
export 'prfy_types/prfy_json.dart';
export 'services/prf_cooldown.dart';
export 'services/prf_rate_limiter.dart';
