![img](https://i.imgur.com/pAUltto.png)

<h3 align="center"><i>Define. Get. Set. Done.</i></h3>
<p align="center">
        <img src="https://img.shields.io/codefactor/grade/github/jozzzzep/prf/main?style=flat-square">
        <img src="https://img.shields.io/github/license/jozzzzep/prf?style=flat-square">
        <img src="https://img.shields.io/pub/points/prf?style=flat-square">
        <img src="https://img.shields.io/pub/v/prf?style=flat-square">
</p>

No boilerplate. No repeated strings. No setup. Define your variables once, then `get()` and `set()` them anywhere with zero friction. `prf` makes local persistence faster, simpler, and easier to scale.

> Supports more types than SharedPreferences out of the box ‚Äî including `DateTime`, `Uint8List`, enums, and full JSON.

- [Introduction](#-define--get--set--done)
- [Why Use `prf`?](#-why-use-prf)
- [**SharedPreferences** vs `prf`](#-sharedpreferences-vs-prf)
- [Setup & Basic Usage (Step-by-Step)](#-setup--basic-usage-step-by-step)
- [Available Methods for All `prf` Types](#-available-methods-for-all-prf-types)
- [Supported `prf` Types](#-supported-prf-types)
- [Migrating from SharedPreferences to `prf`](#-migrating-from-sharedpreferences-to-prf)
- [Roadmap & Future Plans](#Ô∏è-roadmap--future-plans)
- [Why `prf` Wins in Real Apps](#-why-prf-wins-in-real-apps)

# ‚ö° Define ‚Üí Get ‚Üí Set ‚Üí Done

Just define your variable once ‚Äî no strings, no boilerplate:

```dart
final username = PrfString('username');
```

Then get it:

```dart
final value = await username.get();
```

Or set it:

```dart
await username.set('Joey');
```

That‚Äôs it. You're done.

> Works with: `int`, `double`, `bool`, `String`, `List<String>`,  
> and advanced types like `DateTime`, `Uint8List`, enums, and full JSON objects.

---

### üî• Why Use `prf`

Working with `SharedPreferences` often leads to:

- Repeated string keys
- Manual casting and null handling
- Verbose async boilerplate
- Scattered, hard-to-maintain logic

`prf` solves all of that with a **one-line variable definition** that‚Äôs **type-safe**, **cached**, and **instantly usable** throughout your app. No key management, no setup, no boilerplate, no `.getString(...)` everywhere.

---

### What Sets `prf` Apart?

- ‚úÖ **Single definition** ‚Äî just one line to define, then reuse anywhere
- ‚úÖ **Type-safe** ‚Äî no casting, no runtime surprises
- ‚úÖ **Automatic caching** ‚Äî values are stored in memory after the first read
- ‚úÖ **Lazy initialization** ‚Äî no need to manually call `SharedPreferences.getInstance()`
- ‚úÖ **Supports more than just primitives**
  - `String`, `int`, `double`, `bool`, `List<String>`
  - `DateTime`, `Uint8List`, enums, and full JSON objects
- ‚úÖ **Built for testing** ‚Äî easily reset or mock storage in tests
- ‚úÖ **Cleaner codebase** ‚Äî no more scattered `prefs.get...()` or typo-prone string keys
- ‚úÖ **Isolate-safe** ‚Äî built on `SharedPreferencesAsync` for full isolate compatibility, **with caching on top**, making it faster and more ergonomic than working with raw `SharedPreferencesAsync` directly

---

### üîÅ `SharedPreferences` vs `prf`

| Feature                         | `SharedPreferences` (raw)                                                                 | `prf`                                                               |
| ------------------------------- | ----------------------------------------------------------------------------------------- | ------------------------------------------------------------------- |
| **Define Once, Reuse Anywhere** | ‚ùå Manual strings everywhere                                                              | ‚úÖ One-line variable definition                                     |
| **Type Safety**                 | ‚ùå Requires manual casting                                                                | ‚úÖ Fully typed, no casting needed                                   |
| **Readability**                 | ‚ùå Repetitive and verbose                                                                 | ‚úÖ Clear, concise, expressive                                       |
| **Centralized Keys**            | ‚ùå You manage key strings                                                                 | ‚úÖ Keys are defined as variables                                    |
| **Caching**                     | ‚ùå No built-in caching                                                                    | ‚úÖ Automatic in-memory caching                                      |
| **Lazy Initialization**         | ‚ùå Must await `getInstance()` manually                                                    | ‚úÖ Internally managed                                               |
| **Supports Primitives**         | ‚úÖ Yes                                                                                    | ‚úÖ Yes                                                              |
| **Supports Advanced Types**     | ‚ùå No (`DateTime`, `enum`, etc. must be encoded manually)                                 | ‚úÖ Built-in support for `DateTime`, `Uint8List`, `enum`, `JSON`     |
| **Isolate Support**             | ‚ö†Ô∏è Partial ‚Äî only works with `SharedPreferencesAsync`, but still inherits all limitations | ‚úÖ Full isolate-safe support with async backen and built-in caching |

# üìå Code Comparison

**Using `SharedPreferences`:**

```dart
final prefs = await SharedPreferences.getInstance();
await prefs.setString('username', 'Joey');
final username = prefs.getString('username') ?? '';
```

**Using `prf`:**

```dart
final username = PrfString('username');
await username.set('Joey');
final name = await username.get();
```

If you're tired of:

- Duplicated string keys
- Manual casting and null handling
- Scattered boilerplate

Then `prf` is your drop-in solution for **fast, safe, scalable, and elegant local persistence**.

# üöÄ Setup & Basic Usage (Step-by-Step)

### Step 1: Add `prf` to your `pubspec.yaml`

```yaml
dependencies:
  prf: ^latest
```

Then run:

```bash
flutter pub get
```

---

### Step 2: Define Your Variable

You only need **one line** to create a saved variable.  
For example, to save how many coins a player has:

```dart
final playerCoins = PrfInt('player_coins', defaultValue: 0);
```

> This means:
>
> - You're saving an `int` (number)
> - The key is `'player_coins'`
> - If it's empty, it starts at `0`

---

### Step 3: Save a Value

To give the player 100 coins:

```dart
await playerCoins.set(100);
```

---

### Step 4: Read the Value

To read how many coins the player has:

```dart
final coins = await playerCoins.get();
print('Coins: $coins'); // 100
```

That‚Äôs it! üéâ You don‚Äôt need to manage string keys or setup anything. Just define once, then use anywhere in your app.

# üß∞ Available Methods for All `prf` Types

| Method                    | Description                                      |
| ------------------------- | ------------------------------------------------ |
| `get()`                   | Returns the current value (cached or from disk). |
| `set(value)`              | Saves the value and updates the cache.           |
| `remove()`                | Deletes the value from storage and memory.       |
| `isNull()`                | Returns `true` if the value is `null`.           |
| `getOrFallback(fallback)` | Returns the value or a fallback if `null`.       |
| `existsOnPrefs()`         | Checks if the key exists in SharedPreferences.   |

> Available on all `prf` types ‚Äî consistent, type-safe, and ready anywhere in your app.

# üî§ Supported `prf` Types

Define your variable once with a type that fits your use case. Every type supports `.get()`, `.set()`, `.remove()`, and more ‚Äî all cached, type-safe, and ready to use.

| Type           | Class           | Common Use Cases                              |
| -------------- | --------------- | --------------------------------------------- |
| `bool`         | `PrfBool`       | Feature flags, settings toggles               |
| `int`          | `PrfInt`        | Counters, scores, timestamps                  |
| `double`       | `PrfDouble`     | Ratings, sliders, precise values              |
| `String`       | `PrfString`     | Usernames, tokens, IDs                        |
| `List<String>` | `PrfStringList` | Tags, recent items, multi-select options      |
| `Uint8List`    | `PrfBytes`      | Binary data (images, keys, QR codes)          |
| `DateTime`     | `PrfDateTime`   | Timestamps, cooldowns, scheduled actions      |
| `enum`         | `PrfEnum<T>`    | Typed modes, states, user roles               |
| `T (via JSON)` | `PrfJson<T>`    | Full model objects with `toJson` / `fromJson` |

### ‚úÖ All Types Support:

- `get()` ‚Äì read the current value (cached or from disk)
- `set(value)` ‚Äì write and cache the value
- `remove()` ‚Äì delete from disk and cache
- `isNull()` ‚Äì check if null
- `getOrFallback(default)` ‚Äì safely access with fallback
- `existsOnPrefs()` ‚Äì check if a key is stored

### üß† Custom Types? No Problem

Want to persist something more complex? Use `PrfJson<T>` with any model that supports `toJson` and `fromJson`.

```dart
final userData = PrfJson<User>(
  'user',
  fromJson: (json) => User.fromJson(json),
  toJson: (user) => user.toJson(),
);
```

Or use `PrfEncoded<TSource, TStore>` to define your own encoding logic (e.g., compress/encrypt/etc).

# üîÅ Migrating from SharedPreferences to `prf`

Whether you're using the modern `SharedPreferencesAsync` or the legacy `SharedPreferences`, migrating to `prf` is simple and gives you cleaner, type-safe, and scalable persistence.

---

### ‚úÖ If you're already using `SharedPreferencesAsync`

You can switch to `prf` with **zero configuration** ‚Äî just use the same keys.

#### Before (`SharedPreferencesAsync`):

```dart
final prefs = SharedPreferencesAsync();
await prefs.setBool('dark_mode', true);
final isDark = await prefs.getBool('dark_mode');
```

#### After (`prf`):

```dart
final darkMode = PrfBool('dark_mode');
await darkMode.set(true);
final isDark = await darkMode.get();
```

> ‚úÖ **As long as you're using the same keys, your data will still be there. No migration needed.**  
> üßº **Or ‚Äî if you don't care about previously stored values**, you can start fresh and use `prf` types right away.  
> They‚Äôre ready to go with clean APIs and built-in caching for all variable types (`bool`, `int`, `DateTime`, `Uint8List`, enums, and more).

---

### ‚úÖ If you're using the legacy `SharedPreferences` class

You can still switch to `prf` using the same keys:

#### Before (`SharedPreferences`):

```dart
final prefs = await SharedPreferences.getInstance();
await prefs.setString('username', 'Joey');
final name = prefs.getString('username');
```

#### After (`prf`):

```dart
final username = PrfString('username');
await username.set('Joey');
final name = await username.get();
```

> ‚úÖ This works as long as you're still using the same backend ‚Äî either legacy or explicitly configured.  
> üßº You can also start clean and let `prf` handle new storage from scratch, using only its own types.

---

### ‚ö†Ô∏è If your app is already in production using `SharedPreferences`

If your app previously used `SharedPreferences` (the legacy API), and you're now using `prf` (which defaults to `SharedPreferencesAsync`):

- You **must run a one-time migration** to move your data into the new backend (especially on Android, where the storage backend switches to DataStore).

Run this **before any reads or writes**, ideally at app startup:

```dart
await Prf.migrateFromLegacyPrefsIfNeeded();
```

> This ensures your old values are migrated into the new system.  
> It is safe to call multiple times ‚Äî migration will only occur once.

---

### üßº Summary

| Case                                   | Do you need to migrate?     | Do your keys stay the same? |
| -------------------------------------- | --------------------------- | --------------------------- |
| Using `SharedPreferencesAsync`         | ‚ùå No migration needed      | ‚úÖ Yes                      |
| Using `SharedPreferences` (dev only)   | ‚ùå No migration needed      | ‚úÖ Yes                      |
| Using `SharedPreferences` (production) | ‚úÖ Yes ‚Äî run migration once | ‚úÖ Yes                      |
| Starting fresh                         | ‚ùå No migration, no legacy  | üîÑ You can pick new keys    |

With `prf`, you get:

- üöÄ **Type-safe, reusable variables**
- üß† **Cleaner architecture**
- üîÑ **Built-in in-memory caching**
- üîê **Isolate-safe behavior** with `SharedPreferencesAsync`
- üì¶ **Out-of-the-box support** for `DateTime`, `Uint8List`, enums, full models (`PrfJson<T>`), and more

# üõ£Ô∏è Roadmap & Future Plans

`prf` is built for simplicity, performance, and scalability. Upcoming improvements focus on expanding flexibility while maintaining a zero-boilerplate experience.

### ‚úÖ Planned Enhancements

- **Improved performance**  
  Smarter caching and leaner async operations.

- **Additional type support**  
  `Duration`, `BigInt`, encrypted strings, and enhanced `PrfJson<T>`.

- **Custom storage** _(experimental)_  
  Support for alternative adapters (Hive, Isar, file system).

- **Testing & tooling**  
  In-memory test adapter, debug inspection tools, and test utilities.

- **Optional code generation**  
  Annotations for auto-registering variables and reducing manual setup.

# üîç Why `prf` Wins in Real Apps

Working with `SharedPreferences` directly can quickly become **verbose, error-prone, and difficult to scale**. Whether you‚Äôre building a simple prototype or a production-ready app, clean persistence matters.

### ‚ùå The Problem with Raw SharedPreferences

Even in basic use cases, you're forced to:

- Reuse raw string keys (risk of typos and duplication)
- Manually cast and fallback every read
- Handle async boilerplate (`getInstance`) everywhere
- Encode/decode complex types manually
- Spread key logic across multiple files

Let‚Äôs see how this unfolds in practice.

---

### üëé Example: Saving and Reading Multiple Values

**Goal**: Save and retrieve a `username`, `isFirstLaunch`, and a `signupDate`.

### SharedPreferences (verbose and repetitive)

```dart
final prefs = await SharedPreferences.getInstance();

// Save values
await prefs.setString('username', 'Joey');
await prefs.setBool('is_first_launch', false);
await prefs.setString(
  'signup_date',
  DateTime.now().toIso8601String(),
);

// Read values
final username = prefs.getString('username') ?? '';
final isFirstLaunch = prefs.getBool('is_first_launch') ?? true;
final signupDateStr = prefs.getString('signup_date');
final signupDate = signupDateStr != null
  ? DateTime.tryParse(signupDateStr)
  : null;
```

üîª **Issues:**

- Repeated string keys ‚Äî no compile-time safety
- Manual fallback handling and parsing
- No caching ‚Äî every `.get` hits disk
- Boilerplate increases exponentially with more values

---

### ‚úÖ Example: Same Logic with `prf`

```dart
final username = PrfString('username');
final isFirstLaunch = PrfBool('is_first_launch', defaultValue: true);
final signupDate = PrfDateTime('signup_date');

// Save
await username.set('Joey');
await isFirstLaunch.set(false);
await signupDate.set(DateTime.now());

// Read
final name = await username.get();         // 'Joey'
final first = await isFirstLaunch.get();   // false
final date = await signupDate.get();       // DateTime instance
```

üí° Defined once, used anywhere ‚Äî fully typed, cached, and clean.

---

### ü§Ø It Gets Worse with Models

Storing a `User` model in raw `SharedPreferences` requires:

1. Manual `jsonEncode` / `jsonDecode`
2. Validation on read
3. String-based key tracking

### SharedPreferences with Model:

```dart
final prefs = await SharedPreferences.getInstance();

final json = jsonEncode(user.toJson());
await prefs.setString('user_data', json);

// Read
final raw = prefs.getString('user_data');
User? user;
if (raw != null) {
  try {
    final decoded = jsonDecode(raw);
    user = User.fromJson(decoded);
  } catch (_) {
    // fallback or error
  }
}
```

---

### ‚úÖ Same Logic with `prf`

```dart
final userData = PrfJson<User>(
  'user_data',
  fromJson: User.fromJson,
  toJson: (u) => u.toJson(),
);

// Save
await userData.set(user);

// Read
final savedUser = await userData.get(); // User?
```

üß† Fully typed. Automatically parsed. Fallback-safe. Reusable across your app.

---

### ‚öôÔ∏è Built for Real Apps

`prf` was built to eliminate the day-to-day pain of using SharedPreferences in production codebases:

- ‚úÖ Define once ‚Äî reuse anywhere
- ‚úÖ Clean API ‚Äî `get()`, `set()`, `remove()`, `isNull()` for all types
- ‚úÖ Supports advanced types: `DateTime`, `Uint8List`, `enum`, `JSON`
- ‚úÖ Automatic caching ‚Äî fast access after first read
- ‚úÖ Test-friendly ‚Äî easily reset, mock, or inspect values

---

## üîó License MIT ¬© Jozz
